{
  "hash": "ea90dfc7b813fc07924ad9b317311f6f",
  "result": {
    "engine": "knitr",
    "markdown": "# Iteration & Functions {#sec-func}\n\n<div class=\"right meme\"><img src=\"images/memes/functions.jpg\" alt=\"History channel aliens conspiracy guy. Top text: I've got functions inside functions...; Bottom text: ... inside functions.\" /></div>\n\n## Intended Learning Outcomes {#sec-ilo-func - .ilo}\n\n- [ ] Work with basic iteration functions: `rep`, `seq`, `replicate`\n- [ ] Use `purrr::map()` and `apply()` functions\n- [ ] Write your own custom functions with `function()` \n\n## Setup  {#sec-setup-func -}\n\n1. Open your `reprores` project \n1. Create a new quarto file called `03-dataviz.qmd`\n1. Update the YAML header \n1. Replace the setup chunk with the one below: \n\n````\n```{{r}}\n#| label: setup\n#| include: false\nlibrary(tidyverse)  # loads purrr for iteration\nlibrary(broom)      # converts test output to tidy tables\n\nset.seed(8675309) # makes sure random numbers are reproducible\n```\n````\n\n\n\nDownload the [Apply functions with purrr cheat sheet](https://rstudio.github.io/cheatsheets/html/purrr.html).\n\n## Iteration functions {#sec-iteration-functions}\n\nIn the next two lectures, we are going to learn more about <a href='https://psyteachr.github.io/glossary/i#iteration' target='_blank' class='glossary' title='Repeating a process or function'>iteration</a> (doing the same commands over and over) and custom <a href='https://psyteachr.github.io/glossary/f#function' target='_blank' class='glossary' title='A named section of code that can be reused.'>functions</a> through a data simulation exercise, which will also prepare us more traditional statistical topics. We first learned about the two basic iteration functions, `rep()` and `seq()` in the [Working with Data](#rep_seq) chapter.\n\n### rep()\n\nThe function `rep()` lets you repeat the first argument a number of times.\n\nUse `rep()` to create a vector of alternating `\"A\"` and `\"B\"` values of length 24.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(\"A\", \"B\"), 12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\"\n[20] \"B\" \"A\" \"B\" \"A\" \"B\"\n```\n\n\n:::\n:::\n\n\nIf you don't specify what the second argument is, it defaults to `times`, repeating the vector in the first argument that many times. Make the same vector as above, setting the second argument explicitly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(\"A\", \"B\"), times = 12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\"\n[20] \"B\" \"A\" \"B\" \"A\" \"B\"\n```\n\n\n:::\n:::\n\n\nIf the second argument is a vector that is the same length as the first argument, each element in the first vector is repeated than many times. Use `rep()` to create a vector of 11 `\"A\"` values followed by 3 `\"B\"` values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(\"A\", \"B\"), c(11, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"B\" \"B\" \"B\"\n```\n\n\n:::\n:::\n\n\nYou can repeat each element of the vector a sepcified number of times using the `each` argument, Use `rep()` to create a vector of 12 `\"A\"` values followed by 12 `\"B\"` values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(\"A\", \"B\"), each = 12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"B\" \"B\" \"B\" \"B\" \"B\" \"B\" \"B\"\n[20] \"B\" \"B\" \"B\" \"B\" \"B\"\n```\n\n\n:::\n:::\n\n\nWhat do you think will happen if you set both `times` to 3 and `each` to 2?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(\"A\", \"B\"), times = 3, each = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"A\" \"B\" \"B\" \"A\" \"A\" \"B\" \"B\" \"A\" \"A\" \"B\" \"B\"\n```\n\n\n:::\n:::\n\n\n\n### seq()\n\nThe function `seq()` is useful for generating a sequence of numbers with some pattern.\n\nUse `seq()` to create a vector of the integers 0 to 10.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(0, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\nYou can set the `by` argument to count by numbers other than 1 (the default). Use `seq()` to create a vector of the numbers 0 to 100 by 10s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(0, 100, by = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   0  10  20  30  40  50  60  70  80  90 100\n```\n\n\n:::\n:::\n\n\nThe argument `length.out` is useful if you know how many steps you want to divide something into. Use `seq()` to create a vector that starts with 0, ends with 100, and has 12 equally spaced steps (hint: how many numbers would be in a vector with 2 *steps*?).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(0, 100, length.out = 13)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   0.000000   8.333333  16.666667  25.000000  33.333333  41.666667\n [7]  50.000000  58.333333  66.666667  75.000000  83.333333  91.666667\n[13] 100.000000\n```\n\n\n:::\n:::\n\n\n### replicate() \n\nYou can use the `replicate()` function to run a function `n` times.\n\nFor example, you can get 3 sets of 5 numbers from a random normal distribution by setting `n` to `3` and `expr` to `rnorm(5)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplicate(n = 3, expr = rnorm(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]       [,3]\n[1,]  1.0240772  1.0030439  1.5912356\n[2,] -0.4327152  0.2342534  1.0063919\n[3,]  0.4384483 -0.1217803 -1.7631158\n[4,] -1.4106443 -0.3635024 -1.0988308\n[5,]  0.9016948  0.5873456  0.7136377\n```\n\n\n:::\n:::\n\n\nBy default, `replicate()` simplifies your result into a <a href='https://psyteachr.github.io/glossary/m#matrix' target='_blank' class='glossary' title='A container data type consisting of numbers arranged into a fixed number of rows and columns'>matrix</a> that is easy to convert into a table if your function returns vectors that are the same length. If you'd rather have a list of vectors, set `simplify = FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplicate(n = 3, expr = rnorm(5), simplify = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] -0.5988848  0.8261559  0.7951251  1.1043681 -2.9012889\n\n[[2]]\n[1]  0.6554194  1.0975918  0.9308105 -0.3094711 -0.1582473\n\n[[3]]\n[1] -0.1497308  1.0791335 -1.1998364 -0.9865283 -0.9067866\n```\n\n\n:::\n:::\n\n\n\n### map() and apply() functions {#map-apply}\n\n`purrr::map()` and `lapply()` return a list of the same length as a vector or list, each element of which is the result of applying a function to the corresponding element. They function much the same, but purrr functions have some optimisations for working with the tidyverse. We'll be working mostly with purrr functions in this course, but apply functions are very common in code that you might see in examples on the web.\n\nImagine you want to calculate the power for a two-sample t-test with a mean difference of 0.2 and SD of 1, for all the sample sizes 100 to 1000 (by 100s). You could run the `power.t.test()` function 20 times and extract the values for \"power\" from the resulting list and put it in a table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np100 <- power.t.test(n = 100, delta = 0.2, sd = 1, type=\"two.sample\")\n# 18 more lines\np1000 <- power.t.test(n = 500, delta = 0.2, sd = 1, type=\"two.sample\")\n\ntibble(\n  n = c(100, \"...\", 1000),\n  power = c(p100$power, \"...\", p1000$power)\n)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|n    |power             |\n|:----|:-----------------|\n|100  |0.290266404572216 |\n|...  |...               |\n|1000 |0.884788352886661 |\n\n</div>\n:::\n:::\n\n\nHowever, the `apply()` and `map()` functions allow you to perform a function on each item in a vector or list. First make an object `n` that is the vector of the sample sizes you want to test, then use `lapply()` or `map()` to run the function `power.t.test()` on each item. You can set other arguments to `power.t.test()` after the function argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- seq(100, 1000, 100)\npcalc <- lapply(n, power.t.test, \n                delta = 0.2, sd = 1, type=\"two.sample\")\n# or\npcalc <- purrr::map(n, power.t.test, \n                delta = 0.2, sd = 1, type=\"two.sample\")\n```\n:::\n\n\nThese functions return a list where each item is the result of `power.t.test()`, which returns a list of results that includes the named item \"power\". This is a special list that has a summary format if you just print it directly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npcalc[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Two-sample t test power calculation \n\n              n = 100\n          delta = 0.2\n             sd = 1\n      sig.level = 0.05\n          power = 0.2902664\n    alternative = two.sided\n\nNOTE: n is number in *each* group\n```\n\n\n:::\n:::\n\n\nBut you can see the individual items using the `str()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npcalc[[1]] |> str()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 8\n $ n          : num 100\n $ delta      : num 0.2\n $ sd         : num 1\n $ sig.level  : num 0.05\n $ power      : num 0.29\n $ alternative: chr \"two.sided\"\n $ note       : chr \"n is number in *each* group\"\n $ method     : chr \"Two-sample t test power calculation\"\n - attr(*, \"class\")= chr \"power.htest\"\n```\n\n\n:::\n:::\n\n\n\n`sapply()` is a version of `lapply()` that returns a vector or array instead of a list, where appropriate. The corresponding purrr functions are `map_dbl()`, `map_chr()`, `map_int()` and `map_lgl()`, which return vectors with the corresponding <a href='https://psyteachr.github.io/glossary/d#data-type' target='_blank' class='glossary' title='The kind of data represented by an object.'>data type</a>.\n\nYou can extract a value from a list with the function `[[`. You usually see this written as `pcalc[[1]]`, but if you put it inside backticks, you can use it in apply and map functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(pcalc, `[[`, \"power\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.2902664 0.5140434 0.6863712 0.8064964 0.8847884 0.9333687 0.9623901\n [8] 0.9792066 0.9887083 0.9939638\n```\n\n\n:::\n:::\n\n\nWe use `map_dbl()` here because the value for \"power\" is a <a href='https://psyteachr.github.io/glossary/d#double' target='_blank' class='glossary' title='A data type representing a real decimal number'>double</a>.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_dbl(pcalc, `[[`, \"power\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.2902664 0.5140434 0.6863712 0.8064964 0.8847884 0.9333687 0.9623901\n [8] 0.9792066 0.9887083 0.9939638\n```\n\n\n:::\n:::\n\n\nWe can use the `map()` functions inside a `mutate()` function to run the `power.t.test()` function on the value of `n` from each row of a table, then extract the value for \"power\", and delete the column with the power calculations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmypower <- tibble(\n  n = seq(100, 1000, 100)) |>\n  mutate(pcalc = purrr::map(n, power.t.test, \n                            delta = 0.2, \n                            sd = 1, \n                            type=\"two.sample\"),\n         power = purrr::map_dbl(pcalc, `[[`, \"power\")) |>\n  select(-pcalc)\n```\n:::\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Power for a two-sample t-test with d = 0.2](images/figures/fig-purrr-plot-1.png){#fig-purrr-plot width=100%}\n:::\n:::\n\n\n\n## Custom functions {#sec-custom-functions}\n\nIn addition to the built-in functions and functions you can access from packages, you can also write your own functions (and eventually even packages!).\n\n### Structuring a function {#structure-function}\n\nThe general structure of a function is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(my_args) {\n  # process the arguments\n  # return some value\n}\n```\n:::\n\n\nHere is a very simple function. Can you guess what it does?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd1 <- function(my_number) {\n  my_number + 1\n}\n\nadd1(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\nLet's make a function that reports p-values in APA format (with \"p = [rounded value]\" when p >= .001 and \"p < .001\" when p < .001).\n\nFirst, we have to name the function. You can name it anything, but try not to duplicate existing functions or you will overwrite them. For example, if you call your function `rep`, then you will need to use `base::rep()` to access the normal `rep` function. Let's call our p-value function `report_p` and set up the framework of the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_p <- function() {\n}\n```\n:::\n\n\n### Arguments {#arguments}\n\nWe need to add one <a href='https://psyteachr.github.io/glossary/a#argument' target='_blank' class='glossary' title='A variable that provides input to a function.'>argument</a>, the p-value you want to report. The names you choose for the arguments are private to that argument, so it is not a problem if they conflict with other variables in your script. You put the arguments in the parentheses of `function()` in the order you want them to default (just like the built-in functions you've used before). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_p <- function(p) {\n}\n```\n:::\n\n\n### Argument defaults {#defaults}\n\nYou can add a default value to any argument. If that argument is skipped, then the function uses the default argument. It probably doesn't make sense to run this function without specifying the p-value, but we can add a second argument called `digits` that defaults to 3, so we can round p-values to any number of digits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_p <- function(p, digits = 3) {\n}\n```\n:::\n\n\nNow we need to write some code inside the function to process the input arguments and turn them into a **return**ed output. Put the output as the last item in function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_p <- function(p, digits = 3) {\n  if (p < .001) {\n    reported = \"p < .001\"\n  } else {\n    roundp <- round(p, digits)\n    reported = paste(\"p =\", roundp)\n  }\n  \n  reported\n}\n```\n:::\n\n\nYou might also see the returned output inside of the `return()` function. This does the same thing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_p <- function(p, digits = 3) {\n  if (p < .001) {\n    reported = \"p < .001\"\n  } else {\n    roundp <- round(p, digits)\n    reported = paste(\"p =\", roundp)\n  }\n  \n  return(reported)\n}\n```\n:::\n\n\nWhen you run the code defining your function, it doesn't output anything, but makes a new object in the Environment tab under **`Functions`**. Now you can run the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_p(0.04869)\nreport_p(0.0000023)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"p = 0.049\"\n[1] \"p < .001\"\n```\n\n\n:::\n:::\n\n\n### Scope {#scope}\n\nWhat happens in a function stays in a function. You can change the value of a variable passed to a function, but that won't change the value of the variable outside of the function, even if that variable has the same name as the one in the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreported <- \"not changed\"\n\n# inside this function, reported == \"p = 0.002\"\nreport_p(0.0023) \n\nreported # still \"not changed\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"p = 0.002\"\n[1] \"not changed\"\n```\n\n\n:::\n:::\n\n\n\n### Warnings and errors {#warnings-errors}\n\n::: {.try}\nWhat happens when you omit the argument for `p`? Or if you set `p` to 1.5 or \"a\"?</p>\n:::\n\nYou might want to add a more specific warning and stop running the function code if someone enters a value that isn't a number. You can do this with the `stop()` function.\n\nIf someone enters a number that isn't possible for a p-value (0-1), you might want to warn them that this is probably not what they intended, but still continue with the function. You can do this with `warning()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_p <- function(p, digits = 3) {\n  if (!is.numeric(p)) stop(\"p must be a number\")\n  if (p <= 0) warning(\"p-values are normally greater than 0\")\n  if (p >= 1) warning(\"p-values are normally less than 1\")\n  \n  if (p < .001) {\n    reported = \"p < .001\"\n  } else {\n    roundp <- round(p, digits)\n    reported = paste(\"p =\", roundp)\n  }\n  \n  reported\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_p()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in report_p(): argument \"p\" is missing, with no default\n```\n\n\n:::\n\n```{.r .cell-code}\nreport_p(\"a\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in report_p(\"a\"): p must be a number\n```\n\n\n:::\n\n```{.r .cell-code}\nreport_p(-2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in report_p(-2): p-values are normally greater than 0\n```\n\n\n:::\n\n```{.r .cell-code}\nreport_p(2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in report_p(2): p-values are normally less than 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"p < .001\"\n[1] \"p = 2\"\n```\n\n\n:::\n:::\n\n\n## Iterating your own functions\n\n### Build code\n\nFirst, let's build up the code that we want to iterate.\n\n#### Simulate and structure data\n\nCreate a vector of 20 random numbers drawn from a normal distribution with a mean of 5 and standard deviation of 1 using the `rnorm()` function and store them in the variable `A`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- rnorm(20, mean = 5, sd = 1)\n```\n:::\n\n\nA `tibble` is a type of table or `data.frame`. The function `tibble::tibble()` creates a tibble with a column for each argument. Each argument takes the form `column_name = data_vector`.\n\nCreate a table called `dat` including two vectors: `A` that is a vector of 20 random normally distributed numbers with a mean of 5 and SD of 1, and `B` that is a vector of 20 random normally distributed numbers with a mean of 5.5 and SD of 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(\n  A = rnorm(20, 5, 1),\n  B = rnorm(20, 5.5, 1)\n)\n```\n:::\n\n\n#### Statistical test\n\nYou can run a Welch two-sample t-test by including the two samples you made as the first two arguments to the function `t.test`. You can reference one column of a table by its names using the format `table_name$column_name`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test(dat$A, dat$B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWelch Two Sample t-test\n\ndata:  dat$A and dat$B\nt = 0.6844, df = 34.978, p-value = 0.4982\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.3888602  0.7843838\nsample estimates:\nmean of x mean of y \n 5.408082  5.210320 \n```\n\n\n:::\n:::\n\n\nYou can also convert the table to long format using the `gather` function and specify the t-test using the format `dv_column~grouping_column`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongdat <- gather(dat, group, score, A:B)\n\nt.test(score~group, data = longdat) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWelch Two Sample t-test\n\ndata:  score by group\nt = 0.6844, df = 34.978, p-value = 0.4982\nalternative hypothesis: true difference in means between group A and group B is not equal to 0\n95 percent confidence interval:\n -0.3888602  0.7843838\nsample estimates:\nmean in group A mean in group B \n       5.408082        5.210320 \n```\n\n\n:::\n:::\n\n\n#### Tidy output\n\nYou can use the function `broom::tidy()` to extract the data from a statistical test in a table format. The example below pipes everything together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  A = rnorm(20, 5, 1),\n  B = rnorm(20, 5.5, 1)\n) |>\n  gather(group, score, A:B) |>\n  t.test(score~group, data = _) |>\n  broom::tidy()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   estimate| estimate1| estimate2| statistic|   p.value| parameter|  conf.low| conf.high|method                  |alternative |\n|----------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|:-----------------------|:-----------|\n| -0.4807365|  5.097443|   5.57818| -1.455418| 0.1537959|  37.86072| -1.149491| 0.1880185|Welch Two Sample t-test |two.sided   |\n\n</div>\n:::\n:::\n\n\n::: {.callout-note}\nIn the pipeline above, `t.test(score~group, data = _)` uses the `_` notation to change the location of the piped-in data table from it's default position as the first argument to a different position. \n:::\n\n#### Extract important values\n\nFinally, we can extract a single value from this results table using `pull()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  A = rnorm(20, 5, 1),\n  B = rnorm(20, 5.5, 1)\n) |>\n  gather(group, score, A:B) |>\n  t.test(score~group, data = _) |>\n  broom::tidy() |>\n  pull(p.value)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.849082\n```\n\n\n:::\n:::\n\n\n### Custom function\n\nNext, we can group the code above inside a function.\n\nFirst, name your function `t_sim` and wrap the code above in a function with no arguments. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nt_sim <- function() {\n  tibble(\n    A = rnorm(20, 5, 1),\n    B = rnorm(20, 5.5, 1)\n  ) |>\n    gather(group, score, A:B) |>\n    t.test(score~group, data = _) |>\n    broom::tidy() |>\n    pull(p.value) \n}\n```\n:::\n\n\nRun it a few times to see what happens.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt_sim()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2142142\n```\n\n\n:::\n:::\n\n\n#### Iterate\n\nLet's run the `t_sim` function 1000 times, assign the resulting p-values to a vector called `reps`, and check what proportion of p-values are lower than alpha (e.g., .05). This number is the power for this analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreps <- replicate(1000, t_sim())\nalpha <- .05\npower <- mean(reps < alpha)\npower\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.329\n```\n\n\n:::\n:::\n\n\n#### Set seed {#seed}\n\nYou can use the `set.seed` function before you run a function that uses random numbers to make sure that you get the same random data back each time. You can use any integer you like as the seed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(90201)\n```\n:::\n\n\n::: {.callout-warning}\nMake sure you don't ever use `set.seed()` **inside** of a simulation function, or you will just simulate the exact same data over and over again.\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Meme from &commat;KellyBodwin: if you can explain why this is funny, you understand seeds](images/memes/seed_alignment.png){#fig-seed-alignment fig-alt='An alignment chart meme: Lawful Good = set.seed(1234), Neutral Good = *picks random number, sets it as seed*, Chaotic Good = *pop culture reference*, Lawful Neutral = set.seed(420), True Neutral = set.seed(1), Chaotic Neutral = str <-\\'I am awesome.\\'; set.seed(str_length(str)), Lawful Evil =set.seed(666), Neutral Evil: *does not set a seed*, Chaotic Evil = set.seed(.Random.seed[1])' width=100%}\n:::\n:::\n\n\n#### Add arguments\n\nYou can just edit your function each time you want to calculate power for a different sample n, but it is more efficient to build this into your function as an arguments. Redefine `t_sim`, setting arguments for the mean and SD of group A, the mean and SD of group B, and the number of subjects per group. Give them all default values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt_sim <- function(n = 10, m1=0, sd1=1, m2=0, sd2=1) {\n  tibble(\n    A = rnorm(n, m1, sd1),\n    B = rnorm(n, m2, sd2)\n  ) |>\n    gather(group, score, A:B) |>\n    t.test(score~group, data = _) |>\n    broom::tidy() |>\n    pull(p.value) \n}\n```\n:::\n\n\n### Test your function\n\nTest your function with some different values to see if the results make sense.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt_sim(100)\nt_sim(100, 0, 1, 0.5, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8460064\n[1] 0.0002446404\n```\n\n\n:::\n:::\n\n\nUse `replicate` to calculate power for 100 subjects/group with an effect size of 0.2 (e.g., A: m = 0, SD = 1; B: m = 0.2, SD = 1). Use 1000 replications.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreps <- replicate(1000, t_sim(100, 0, 1, 0.2, 1))\npower <- mean(reps < .05)\npower\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.284\n```\n\n\n:::\n:::\n\n\nCompare this to power calculated from the `power.t.test` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npower.t.test(n = 100, delta = 0.2, sd = 1, type=\"two.sample\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Two-sample t test power calculation \n\n              n = 100\n          delta = 0.2\n             sd = 1\n      sig.level = 0.05\n          power = 0.2902664\n    alternative = two.sided\n\nNOTE: n is number in *each* group\n```\n\n\n:::\n:::\n\n\n\n::: {.try}\nCalculate power via simulation and `power.t.test` for the following tests:\n\n* 20 subjects/group, A: m = 0, SD = 1; B: m = 0.2, SD = 1\n* 40 subjects/group, A: m = 0, SD = 1; B: m = 0.2, SD = 1\n* 20 subjects/group, A: m = 10, SD = 1; B: m = 12, SD = 1.5\n:::\n\n## Exercises\n\nExplain why [this meme](https://www.reddit.com/r/rstatsmemes/comments/wjt9l2/i_made_an_alignment_system_of_loops_in_r_subject/) is funny.\n\n![By arthurwelle on r/rstatsmemes](images/memes/loops-alignment.png){fig-alt=\"See the text below for an accessible version\"}\n\n* Lawful good\n    ``` r\n    library(purrr)\n    walk(rep(\"R!\", 5), print)\n    ```\n* Neutral good\n    ``` r\n    for (i in 1:5) print(\"R!\")\n    ```\n* Chaotic good\n    ``` r\n    for (i in 1:5)\n      print(\"R!\")\n    ```\n* Lawful neutral\n    ``` r\n    print(\"R!\")\n    print(\"R!\")\n    print(\"R!\")\n    print(\"R!\")\n    print(\"R!\")\n    ```\n* True neutral\n    ``` r\n    for (i in 1:5) { \n      print(\"R!\")\n    }\n    ```\n* Chaotic neutral\n    ``` r\n    mapply(\\(x) print(x), rep(\"R!\", 5)) |> \n      invisible()\n    ```\n* Lawful evil\n    ``` r\n    i <<- 1\n    while (i < 6) { \n      print(\"R!\")\n      i + 1 ->> i\n    }\n    ```\n* Neutral evil\n    ``` r\n    f <- function(...) {\n      do.call(print, list(\"R!\"))\n    }\n    lapply(LETTERS[1:5], f) |> \n      invisible()\n    ```\n* Chaotic evil\n    ``` r\n    apply(data.frame(rep(\"R!\", 5)),\n      1,\n      \\(x){cat(x);\n        cat(\"\\n\")}) |>\n    invisible()\n    ```\n\n\n## Glossary {#sec-glossary-func -}\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|term                                        |definition                                                                                   |\n|:-------------------------------------------|:--------------------------------------------------------------------------------------------|\n|[argument](https://psyteachr.github.io/glossary/a#argument){target='_blank' class='glossary'}|A variable that provides input to a function.                                                |\n|[data-type](https://psyteachr.github.io/glossary/d#data-type){target='_blank' class='glossary'}|The kind of data represented by an object.                                                   |\n|[double](https://psyteachr.github.io/glossary/d#double){target='_blank' class='glossary'}|A data type representing a real decimal number                                               |\n|[function](https://psyteachr.github.io/glossary/f#function){target='_blank' class='glossary'}|A named section of code that can be reused.                                                  |\n|[iteration](https://psyteachr.github.io/glossary/i#iteration){target='_blank' class='glossary'}|Repeating a process or function                                                              |\n|[matrix](https://psyteachr.github.io/glossary/m#matrix){target='_blank' class='glossary'}|A container data type consisting of numbers arranged into a fixed number of rows and columns |\n\n\n:::\n:::\n\n\n## Further Resources {#sec-resources-func -}\n\n* Chapters 19 and 21 of [R for Data Science](http://r4ds.had.co.nz)\n* [Apply functions with purrr cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/purrr.pdf)\n",
    "supporting": [
      "08-func_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}